DATE   Feb 1, 2012
AUTHOR Jake jake@keyboardfu.com
TAG    PHP
TAG    Filters

h1. Safe Input With PHP's Filter Functions, II

Continuing from "Safe Input With PHP's Filter Functions, I":/2012/01/18/php-input-filters-1, it's time to nail down efficient filter definitions.

h2. A Peek of What's To Come

I read books backwards: Read the first few pages, read the last chapter, then go back to the front. Knowing the end helps me know what direction I should look in when reading the middle.

Let's look at the end of the book, I want the final filtering definition to look like this:

bc. $values = filter_input_array(INPUT_POST, array(
	'transfer_date' => CustomFilters::timstamp(),
	'desired_funds' => CustomFilters::validFundRange()
));

h2. Science!

Based on the learning done in the previous article, there are a few things to note:

# @filter_input_array@ and @filter_var_array@ take an array where the key is the name of the incoming data, and the value is some definition of how that data should filter/validate
# The value for a data item contains everything necessary to define it including the filter type and any options
# When using the @FILTER_CALLBACK@ type, any data coming in from the user is sent to the first argument of the callback function

From this information, it's pretty straightforward to hypothesize that a single function could wear two hats: Providing the data definition, and filtering or validating the data.

h2. Validation with Veracity

Without getting obnoxious, let's start with some very simple examples and work up to something a bit more sassy. The trick to this is remembering about @func_num_args()@ and @func_get_args()@. The former will tell us if we are supposed to provide the data definition or do work with incoming data. The latter will fetch the data to do the dirty work with.

h3. Same Face, New Name

bc.. class CustomFilters {
	public static function validInt() {
		return FILTER_VALIDATE_INT;
	}
}

$values = filter_input_array(INPUT_POST, array(
	'ints_rule' => CustomFilters::validInt()
));

p. Using an existing filter, there's no need to worry about incoming data. Also works with the more complex array definitions:

bc.. class CustomFilters {
	public static function validInt() {
		return array(
		'filter' => FILTER_VALIDATE_INT,
		'options' => array(
			'min_range' => 1,
			'max_range' => 100
		);
	}
}

$values = filter_input_array(INPUT_POST, array(
	'ints_rule' => CustomFilters::validInt()
));

h3. Turning Custom Filters Up

I want a filter that will take any user's convoluted representation of money and turn it into a consistent value - both for presentation and processing.

bc.. class CustomFilters {
	public static function prettyMoney () {
		if (func_num_args()) {
			$raw = func_get_arg(0);
			$stripped = preg_replace('/[^\d.]/', '', $raw);
			if ($stripped != '') {
				return money_format('%n', $stripped);
			} else {
				return false;
			}
		} else {
			return array(
				'filter' => FILTER_CALLBACK,
				'options' => array(__CLASS__, __FUNCTION__)
			);
		}
	}
}

$values = filter_input_array(INPUT_POST, array(
	'money' => CustomFilters::prettyMoney()
));

p. On initial execution, @func_num_args()@ returns zero, which causes the following to return:

bc. array(
	'filter' => FILTER_CALLBACK,
	'options' => array(__CLASS__, __FUNCTION__)
);

It's best to leave @__CLASS__@ and @__FUNCTION__@ as is since manually filling those values in is just another thing to remember when making new filters.

When the form posts and sends data in, the callback is called with the value from the user. @func_get_arg(0)@ snags the only value sent in, trims it, strips non-digits, and then returns the value formatted to the locale's representation of money.

How good is it? It'll take practically anything and make it money.
* $1,234,567.00
* 1234567.00
* 1234567
* 1,234,567
* $12,34,56,7
* $1234567.00
* 1,2 skip a few 34567

All of the above will turn into *$1,234,567.00* upon posting. Additionally, the formatted value is reposted if another part of the form fails.

h2. To the Filter-Mobile

And with that, I conclude filtering user input. This method of centralizing custom filters will help save time, especially in a collaborative environment. Other developers can optimize what you build and you can optimize what you find, as well.

The prettyMoney filter above is actually something I've used on many a production website. It went through a few iterations and a ton of failures before reaching it's current point - Never stop fiddling.
